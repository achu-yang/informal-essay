# 优化高频执行js代码方法

## 场景
1. 手机号、邮箱验证输入检测
2. 调节窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。
3. 滚动加载，加载更多或滚到底部监听
4. 高频点击提交，表单重复提交


## 防抖

在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
```js
function debounce(fn, delay) {
  var timer; // 维护一个 timer
  return function () {
      var _this = this; // 取debounce执行作用域的this
      // 由于debounce是return了一个匿名函数
      // 当用某个变量接收的时候arguments指向这个变量的参数
      // let a = debounce(fn,delay) <==> function a () {}
      var args = arguments; xl
      if (timer) {
          clearTimeout(timer);
      }
      timer = setTimeout(function () {
          fn.apply(_this, args); // 用apply指向调用debounce的对象，相当于_this.fn(args);
      }, delay);
  };
}
// let a = debounce(function(msg){
//   console.log(msg);
// },1000)
// a('我是第一次')
// a('我是第二次')
// a('我是第三次')
// a('我是第四次') 
// 以上结果控制台只显示 “我是第四次”
```

## 节流

在事件被触发后n秒内不能重新触发。
```js
function throttle (fn, delay) {
  var timer;
  return function () {
    if (timer) return;
    let _this = this;
    let arg = arguments;
    timer = setTimeout(()=>{
      fn.apply(_this,arg);
      clearTimeout(timer);
      timer = null;
    },delay)
  }
}
let a = throttle(function(msg){
  console.log(msg);
},600);
for (let i = 0; i < 4; i++) {
  setTimeout(()=>{
    console.log(`第${i+1}次了`)
    a(i.toString());
  },(i+1) * 500)
```


