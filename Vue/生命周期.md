# new一个Vue发生的事情
1. new Vue会调用 Vue 原型链上的_init方法对 Vue 实例进行初始化；
2. 首先是initLifecycle初始化生命周期，对 Vue 实例内部的一些属性（如 children、parent、isMounted）进行初始化；
3. initEvents，初始化当前实例上的一些自定义事件（Vue.$on）；
4. initRender，解析slots绑定在 Vue 实例上，绑定createElement方法在实例上；
5. 完成对生命周期、自定义事件等一系列属性的初始化后，触发生命周期钩子beforeCreate；
6. initInjections，在初始化data和props之前完成依赖注入（类似于 React.Context）；
7. initState，完成对data和props的初始化，同时对属性完成数据劫持内部，启用监听者对数据进行监听（更改）；
8. initProvide，对依赖注入进行解析；
9. 完成对数据（state 状态）的初始化后，触发生命周期钩子created；
10. 进入挂载阶段，将 vue 模板语法通过vue-loader解析成虚拟 DOM 树，虚拟 DOM 树与数据完成双向绑定，触发生命周期钩子beforeMount；
11. 将解析好的虚拟 DOM 树通过 vue 渲染成真实 DOM，触发生命周期钩子mounted；

1. beforeCreate
已经完成实例化Vue以及初始化事件和生命周期
vue对象和属性没有绑定
2. Created
已经完成Vue属性的挂载
3. beforeMounte
已经完成了编译模板和数据挂载在模板上但还没有显示出来
4. Mounted
已经完成模板内容替换也就是能看到正确数据
5. beforeUpdate
在模板上出现的数据发生变动但是对应的DOM的innerHTML还没变
6. updated
DOM的innerHTML内容变了
7. beforeDestroy
组件销毁前一般用于释放监听器
8. destroyed
组件销毁

activated
组件激活时调用
deactivated
组件激活后调用

一般用于被keep-alive包裹才会有这两个周期
比如动态列表需要缓存状态就可以存起来，等返回时会快速渲染

keep-alive原理
将DOM节点抽象为VNode节点进行缓存保存在this.cache中